# Security Assessment Report
## Lendesk Security Challenge - Web Application Penetration Test

**Assessment Date:** November 17, 2025  
**Assessor:** Sai Teja Bandi  
**Application:** Node.js/TypeScript Notes Management API  
**Version:** 1.0.0

---

## Executive Summary

This report presents the findings from a comprehensive security assessment of a Node.js/TypeScript web application that provides user authentication and note management functionality. The assessment utilized both static application security testing (SAST) and manual code review techniques to identify security vulnerabilities.

**Key Findings:**
- **Critical Vulnerabilities:** 3
- **High Vulnerabilities:** 2
- **Medium Vulnerabilities:** 3
- **Low Vulnerabilities:** 2

The application exhibits multiple **critical security flaws** that could allow unauthorized access to user data, token forgery, and information disclosure. The most severe issue is the complete lack of JWT signature verification, which effectively renders the authentication mechanism useless.

---

## 1. Testing Methodology

### 1.1 Tools and Techniques Used

**Static Analysis:**
- Manual source code review of all TypeScript files
- Pattern-based security scanning using `grep` for common vulnerabilities
- Dependency analysis via `package.json` review
- Configuration and environment file analysis

**Focus Areas:**
- Authentication and authorization mechanisms
- JWT token generation and validation
- Input validation and sanitization
- Data access patterns and storage
- Error handling and information disclosure
- Secrets management
- CORS and security headers configuration

### 1.2 Testing Scope

**In-Scope Components:**
- `/authentication/create-user` - User registration endpoint
- `/authentication/login` - User authentication endpoint
- `/users/:username/notes` - Note creation and retrieval endpoints
- JWT token generation and validation logic
- Redis and file-based data storage implementations
- Password hashing implementation
- Input validation logic

**Analysis Approach:**
1. Reviewed application architecture and data flow
2. Analyzed authentication and authorization implementations
3. Examined input handling and validation
4. Assessed cryptographic implementations
5. Reviewed error handling mechanisms
6. Evaluated configuration and secrets management

---

## 2. Findings

### CRITICAL-01: JWT Token Validation Bypass

**Risk Level:** CRITICAL

**Description:**  
The JWT authentication middleware uses `jwt.decode()` instead of `jwt.verify()` to validate tokens. The `decode()` function simply decodes the JWT payload without verifying the signature, allowing attackers to forge arbitrary tokens.

**Location:** `src/routes/notes.ts`, lines 15-18

```typescript
const authenticateJWT: express.RequestHandler = (req, res, next) => {
  // ... authorization header extraction ...
  const token = authHeader.split(' ')[1];
  try {
    const decoded = jwt.decode(token);  // ❌ NO SIGNATURE VERIFICATION
    (req as any).user = decoded;
    next();
  } catch (err) {
    res.status(403).json({ message: 'Invalid or expired token' });
  }
};
```

**Impact:**  
An attacker can create a valid-looking JWT token with any username without knowing the secret key. This completely bypasses authentication and allows:
- Accessing any user's notes without authentication
- Creating notes on behalf of any user
- Complete authentication bypass for all protected endpoints

**Proof of Concept:**
```bash
# Attacker can create a forged token for any user
# Example: Create token for user "alice" without password
TOKEN=$(echo -n '{"alg":"none"}' | base64).$(echo -n '{"username":"alice"}' | base64).

# Access alice's notes without authentication
curl -H "Authorization: Bearer $TOKEN" http://localhost:5000/users/alice/notes
```

**Remediation:**
1. Replace `jwt.decode()` with `jwt.verify()` and use a strong secret key
2. Store the JWT secret in environment variables, not hardcoded
3. Implement token expiration
4. Add token refresh mechanism

**Recommended Code Fix:**
```typescript
const authenticateJWT: express.RequestHandler = (req, res, next) => {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    res.status(401).json({ message: 'Missing or invalid Authorization header' });
    return;
  }

  const token = authHeader.split(' ')[1];
  try {
    const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-from-env';
    const decoded = jwt.verify(token, JWT_SECRET) as { username: string };
    (req as any).user = decoded;
    next();
  } catch (err) {
    res.status(403).json({ message: 'Invalid or expired token' });
  }
};
```

---

### CRITICAL-02: Hardcoded JWT Secret Key

**Risk Level:** CRITICAL

**Description:**  
The JWT signing secret is hardcoded as the string `'JWT'` in the authentication route, making it trivial for attackers to forge valid tokens once they discover this weak secret.

**Location:** `src/routes/authentication.ts`, line 36

```typescript
const token = jwt.sign({ username: req.body.username }, 'JWT');  // ❌ HARDCODED SECRET
```

**Impact:**
- Predictable and weak secret key
- Any attacker who reviews the code or decompiles the application can create valid tokens
- Combined with the jwt.decode() vulnerability, this makes authentication completely ineffective
- All user accounts are compromised

**Evidence:**
The secret `'JWT'` is only 3 characters, far below the recommended minimum of 256 bits (32 characters) for HS256 algorithm.

**Remediation:**
1. Generate a strong, random secret key (minimum 256 bits)
2. Store the secret in environment variables
3. Never commit secrets to version control
4. Implement key rotation mechanism
5. Use different secrets for different environments

**Recommended Implementation:**
```typescript
// In .env.template
JWT_SECRET=<generate-strong-random-secret-here>
JWT_EXPIRATION=1h

// In src/config.ts
export const config = {
  servicePort: importEnv.SERVICE_PORT,
  redisUrl: importEnv.REDIS_URL,
  jwtSecret: importEnv.JWT_SECRET,
  jwtExpiration: importEnv.JWT_EXPIRATION || '1h',
};

// In src/routes/authentication.ts
const token = jwt.sign(
  { username: req.body.username },
  config.jwtSecret,
  { expiresIn: config.jwtExpiration }
);
```

---

### CRITICAL-03: Broken Access Control - No Authorization Check

**Risk Level:** CRITICAL

**Description:**  
The notes endpoints authenticate users but don't verify that the authenticated user matches the username in the URL path. Any authenticated user can access or modify any other user's notes.

**Location:** `src/routes/notes.ts`, lines 32-50

```typescript
router.post('/:username/notes', authenticateJWT, function (req: express.Request, res: express.Response) {
  getNotesController().then((controller: NotesController) => {
    controller
      .createUserNotes(req.params.username, req.body.notes)  // ❌ NO AUTHORIZATION CHECK
      // ...
  });
});

router.get('/:username/notes', authenticateJWT, function (req: express.Request, res: express.Response) {
  getNotesController().then((controller: NotesController) => {
    controller
      .getUserNotes(req.params.username)  // ❌ NO AUTHORIZATION CHECK
      // ...
  });
});
```

**Impact:**
- Horizontal privilege escalation
- User A can read User B's notes
- User A can create/modify notes for User B
- Complete violation of data confidentiality and integrity
- Violation of OWASP Top 10 - Broken Access Control (A01:2021)

**Proof of Concept:**
```bash
# User "alice" logs in
TOKEN_ALICE=$(curl -s -X POST http://localhost:5000/authentication/login \
  -H "Content-Type: application/json" \
  -d '{"username":"alice","password":"alicepass"}' | jq -r '.token')

# Alice can access Bob's notes using her own token
curl -H "Authorization: Bearer $TOKEN_ALICE" \
  http://localhost:5000/users/bob/notes

# Alice can create notes for Bob
curl -X POST -H "Authorization: Bearer $TOKEN_ALICE" \
  -H "Content-Type: application/json" \
  -d '{"notes":"Malicious note from Alice"}' \
  http://localhost:5000/users/bob/notes
```

**Remediation:**
Implement proper authorization by verifying the authenticated user matches the requested resource owner:

```typescript
router.post('/:username/notes', authenticateJWT, function (req: express.Request, res: express.Response) {
  const authenticatedUser = (req as any).user.username;
  const requestedUsername = req.params.username;
  
  if (authenticatedUser !== requestedUsername) {
    res.status(403).json({ message: 'Forbidden: Cannot access other users\' notes' });
    return;
  }
  
  getNotesController().then((controller: NotesController) => {
    controller.createUserNotes(requestedUsername, req.body.notes)
      .then((notes) => res.json(notes).end())
      .catch(handleUnknownError(res));
  });
});
```

---

### HIGH-01: Sensitive Information Disclosure in Error Responses

**Risk Level:** HIGH

**Description:**  
The error handler exposes full error messages and stack traces to clients, revealing sensitive information about the application's internal structure, file paths, and implementation details.

**Location:** `src/utils/error.ts`, lines 4-14

```typescript
export const handleUnknownError = (res: express.Response) => {
  return (e: Error) => {
    res
      .status(500)
      .json({
        errors: [{
          code: 500,
          message: 'Unknown error',
          details: e.message,      // ❌ EXPOSES ERROR DETAILS
          stack: e.stack           // ❌ EXPOSES STACK TRACE
        }]
      })
      .end();
  };
};
```

**Impact:**
- Information disclosure about application internals
- Stack traces reveal file paths, library versions, and code structure
- Assists attackers in reconnaissance
- May expose database connection strings, internal IPs, or other sensitive data
- Violation of OWASP Top 10 - Security Misconfiguration (A05:2021)

**Evidence:**
Stack traces in production environments can reveal:
- Server-side file paths (`/app/src/controllers/...`)
- Framework and library versions
- Internal function names and logic flow
- Database errors with query details

**Remediation:**
1. Differentiate between development and production error handling
2. Log full errors server-side only
3. Return generic error messages to clients
4. Implement proper error monitoring/logging

**Recommended Implementation:**
```typescript
export const handleUnknownError = (res: express.Response) => {
  return (e: Error) => {
    // Log full error server-side
    console.error('Error occurred:', {
      message: e.message,
      stack: e.stack,
      timestamp: new Date().toISOString()
    });
    
    // Return generic error to client
    const isDevelopment = process.env.NODE_ENV === 'development';
    res.status(500).json({
      errors: [{
        code: 500,
        message: 'An internal error occurred',
        ...(isDevelopment && { details: e.message, stack: e.stack })
      }]
    }).end();
  };
};
```

---

### HIGH-02: Unrestricted CORS Configuration

**Risk Level:** HIGH

**Description:**  
The application uses `cors()` without any configuration, allowing requests from any origin. This permits malicious websites to make authenticated requests to the API on behalf of users.

**Location:** `src/app.ts`, line 9

```typescript
app.use(cors());  // ❌ ALLOWS ALL ORIGINS
```

**Impact:**
- Cross-Site Request Forgery (CSRF) attacks
- Malicious websites can access user data if users are logged in
- API can be called from any domain
- Tokens can be stolen via XSS attacks on any domain
- Data exfiltration from authenticated sessions

**Attack Scenario:**
A user visits a malicious website while logged into the notes application. The malicious site can:
1. Extract the JWT token from localStorage/cookies
2. Make authenticated API calls to read/write notes
3. Exfiltrate sensitive data

**Remediation:**
Configure CORS to only allow trusted origins:

```typescript
import cors from 'cors';

const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'];

app.use(cors({
  origin: function(origin, callback) {
    // Allow requests with no origin (mobile apps, curl, etc.)
    if (!origin) return callback(null, true);
    
    if (allowedOrigins.indexOf(origin) === -1) {
      const msg = 'The CORS policy for this site does not allow access from the specified Origin.';
      return callback(new Error(msg), false);
    }
    return callback(null, true);
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));
```

---

### MEDIUM-01: Missing Input Validation on Notes Endpoint

**Risk Level:** MEDIUM

**Description:**  
The notes creation endpoint doesn't validate the `notes` input, allowing users to submit empty notes, excessively long notes, or potentially malicious content.

**Location:** `src/controllers/notes.ts`, lines 7-10

```typescript
async createUserNotes(username: string, notes: string): Promise<Notes> {
  const existingNotes = await this.notesData.findByUsername(username);
  return this.notesData.create(username, notes);  // ❌ NO VALIDATION
}
```

**Impact:**
- Database/Redis storage exhaustion with large payloads
- Potential for NoSQL injection depending on storage backend
- Acceptance of malicious or malformed data
- No content-length restrictions

**Evidence:**
No validation exists for:
- Note length (could be megabytes)
- Note content (could contain injection payloads)
- Note format or encoding

**Remediation:**
Implement input validation:

```typescript
const MAX_NOTE_LENGTH = 10000; // 10KB

async createUserNotes(username: string, notes: string): Promise<Notes> {
  // Validate input
  if (!notes || typeof notes !== 'string') {
    throw new Error('Notes must be a non-empty string');
  }
  
  if (notes.trim().length === 0) {
    throw new Error('Notes cannot be empty');
  }
  
  if (notes.length > MAX_NOTE_LENGTH) {
    throw new Error(`Notes exceed maximum length of ${MAX_NOTE_LENGTH} characters`);
  }
  
  // Sanitize input if needed
  const sanitizedNotes = notes.trim();
  
  return this.notesData.create(username, sanitizedNotes);
}
```

---

### MEDIUM-02: Weak Password Requirements

**Risk Level:** MEDIUM

**Description:**  
The password validation allows passwords as short as 4 characters, which is insufficient for modern security standards and vulnerable to brute-force attacks.

**Location:** `src/authentication/user.ts`, line 12

```typescript
export const MIN_PASSWORD_LENGTH = 4;  // ❌ TOO WEAK
```

**Impact:**
- Accounts vulnerable to brute-force attacks
- Dictionary attacks more likely to succeed
- Reduced password entropy
- Users may choose weak passwords like "1234"

**Current Password Policy:**
- Minimum length: 4 characters (very weak)
- No complexity requirements
- No restriction on common passwords

**Remediation:**
Implement stronger password requirements:

```typescript
export const MIN_PASSWORD_LENGTH = 12;
export const PASSWORD_REGEX = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/;

export function validateAccount(username: string, password: string) {
  const errors = [];
  
  // ... existing username validation ...
  
  if (!password || password.trim().length === 0) {
    errors.push({ code: UserError.PASSWORD_REQUIRED, message: 'Password is required' });
  } else if (password.length < MIN_PASSWORD_LENGTH) {
    errors.push({
      code: UserError.PASSWORD_TOO_SHORT,
      message: `Password must be at least ${MIN_PASSWORD_LENGTH} characters`,
    });
  } else if (!PASSWORD_REGEX.test(password)) {
    errors.push({
      code: UserError.PASSWORD_COMPLEXITY,
      message: 'Password must contain uppercase, lowercase, number, and special character',
    });
  }
  
  return { errors };
}
```

Additionally, consider implementing:
- Password strength meter on client-side
- Check against common password lists
- Account lockout after failed attempts
- Multi-factor authentication (MFA)

---

### MEDIUM-03: Missing Rate Limiting

**Risk Level:** MEDIUM

**Description:**  
The application has no rate limiting on authentication endpoints, allowing unlimited login attempts and user creation requests. This enables brute-force attacks and account enumeration.

**Location:** `src/routes/authentication.ts` (entire file)

**Impact:**
- Brute-force password attacks
- Account enumeration (determining valid usernames)
- Credential stuffing attacks
- Service abuse through mass account creation
- Resource exhaustion

**Attack Scenarios:**
1. **Brute Force:** Attacker tries thousands of password combinations
2. **Account Enumeration:** Attacker can determine valid usernames by response timing
3. **DoS:** Mass user creation requests could overwhelm the system

**Remediation:**
Implement rate limiting using middleware like `express-rate-limit`:

```bash
npm install express-rate-limit
```

```typescript
import rateLimit from 'express-rate-limit';

// Rate limiter for authentication endpoints
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // Limit each IP to 5 requests per windowMs
  message: 'Too many authentication attempts, please try again later',
  standardHeaders: true,
  legacyHeaders: false,
});

// Apply to authentication routes
router.post('/create-user', authLimiter, function (req, res) { ... });
router.post('/login', authLimiter, function (req, res) { ... });

// Rate limiter for API endpoints
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
});

app.use('/users', apiLimiter);
```

Additional recommendations:
- Implement CAPTCHA after multiple failed attempts
- Add account lockout mechanism
- Use exponential backoff for failed login attempts

---

### LOW-01: Missing Security Headers

**Risk Level:** LOW

**Description:**  
The application doesn't set security-related HTTP headers, leaving it vulnerable to various client-side attacks like clickjacking, XSS, and MIME-type sniffing.

**Location:** `src/app.ts` (missing configuration)

**Missing Headers:**
- `X-Content-Type-Options: nosniff`
- `X-Frame-Options: DENY`
- `X-XSS-Protection: 1; mode=block`
- `Strict-Transport-Security` (HSTS)
- `Content-Security-Policy`

**Impact:**
- Clickjacking attacks
- MIME-type sniffing vulnerabilities
- Cross-Site Scripting (XSS) attacks
- Man-in-the-Middle (MITM) attacks

**Remediation:**
Use the `helmet` middleware to set security headers:

```bash
npm install helmet
```

```typescript
import helmet from 'helmet';

app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  },
}));
```

---

### LOW-02: Insecure File Storage in Console Application

**Risk Level:** LOW

**Description:**  
The console application uses a file-based storage system (`FileUserData`) that writes user data including hashed passwords to `users.json` in the current directory without proper permissions or encryption.

**Location:** `src/data/file/user.ts` and `src/data/file/json-file.ts`

```typescript
protected writeData(data: T) {
  fs.writeFileSync(this.filename, JSON.stringify(data));  // ❌ NO ENCRYPTION, DEFAULT PERMISSIONS
}
```

**Impact:**
- Password hashes stored in plaintext JSON file
- File permissions may allow other users to read
- No encryption at rest
- Data could be exposed if file system is compromised

**Evidence:**
The `.gitignore` file includes `users.json`, indicating this file is created at runtime and should not be committed. However, there's no validation of file permissions or encryption.

**Remediation:**
1. Set restrictive file permissions (600 - owner read/write only)
2. Store sensitive data in secure storage (e.g., encrypted database)
3. Implement encryption at rest
4. Use Redis for all environments (not just development)

```typescript
import fs from 'fs';

protected writeData(data: T) {
  const jsonData = JSON.stringify(data);
  // Write with restrictive permissions
  fs.writeFileSync(this.filename, jsonData, { mode: 0o600 });
}
```

---

## 3. Summary

### 3.1 Overall Risk Posture

The application exhibits a **CRITICAL** overall risk posture with fundamental security flaws in authentication, authorization, and data protection mechanisms. The combination of JWT validation bypass, hardcoded secrets, and broken access control creates a scenario where the application provides essentially **no security** for user data.

**Risk Distribution:**
- 3 Critical vulnerabilities requiring immediate attention
- 2 High vulnerabilities that should be addressed urgently  
- 3 Medium vulnerabilities that need remediation
- 2 Low vulnerabilities for defense-in-depth

### 3.2 Most Critical Issue

**JWT Token Validation Bypass (CRITICAL-01)** is the most critical vulnerability. The use of `jwt.decode()` instead of `jwt.verify()` completely bypasses authentication, allowing any attacker to forge tokens and access any user's data without credentials. This single vulnerability renders all authentication controls ineffective.

### 3.3 General Security Recommendations

#### Immediate Actions (Critical Priority)
1. **Fix JWT validation** - Replace `jwt.decode()` with `jwt.verify()`
2. **Implement proper secret management** - Move JWT secret to environment variables
3. **Add authorization checks** - Verify authenticated user matches resource owner
4. **Disable detailed error messages** - Implement production-safe error handling

#### Short-term Improvements (High Priority)
5. **Configure CORS properly** - Restrict to trusted origins only
6. **Add rate limiting** - Protect authentication endpoints from brute-force
7. **Implement security headers** - Use helmet middleware
8. **Strengthen password policy** - Increase minimum length to 12+ characters

#### Long-term Enhancements (Medium Priority)
9. **Add input validation** - Validate all user inputs including notes content
10. **Implement audit logging** - Log security-relevant events
11. **Add session management** - Implement token refresh and revocation
12. **Security testing** - Integrate SAST/DAST tools in CI/CD pipeline
13. **Dependency scanning** - Regular updates and vulnerability scanning
14. **Multi-factor authentication** - Add MFA for enhanced security

#### Security Development Practices
15. **Security training** - Educate developers on secure coding practices
16. **Code review process** - Implement security-focused code reviews
17. **Threat modeling** - Conduct threat modeling for new features
18. **Penetration testing** - Regular security assessments
19. **Incident response plan** - Prepare for security incidents
20. **Security documentation** - Maintain security architecture documentation

### 3.4 Compliance Considerations

The identified vulnerabilities represent violations of several security standards:

- **OWASP Top 10 2021:**
  - A01:2021 - Broken Access Control
  - A02:2021 - Cryptographic Failures
  - A05:2021 - Security Misconfiguration
  - A07:2021 - Identification and Authentication Failures

- **CWE (Common Weakness Enumeration):**
  - CWE-287: Improper Authentication
  - CWE-798: Use of Hard-coded Credentials
  - CWE-285: Improper Authorization
  - CWE-209: Information Exposure Through Error Messages

---

## 4. Conclusion

This security assessment identified **10 significant vulnerabilities** ranging from Critical to Low severity. The application requires **immediate remediation** of critical authentication and authorization flaws before it can be considered safe for production use.

The development team should prioritize fixing the three critical vulnerabilities as they represent complete compromise of the application's security model. Following that, the high and medium severity issues should be addressed to establish a robust security posture.

With proper remediation of the identified issues and implementation of the recommended security controls, the application can achieve an acceptable security level suitable for production deployment.

---

**Report prepared by:** Sai Teja Bandi  
**Date:** November 17, 2025  
**Classification:** Confidential
